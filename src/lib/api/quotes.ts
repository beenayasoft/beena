import axios from 'axios';

// URL de l'API Backend Django
const API_URL = 'http://localhost:8000/api';

// Cr√©er une instance axios avec config d'authentification
const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Intercepteur pour ajouter le token d'authentification aux requ√™tes
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Types pour les r√©ponses du backend
export interface QuoteStatus {
  DRAFT: 'draft';
  SENT: 'sent';
  ACCEPTED: 'accepted';
  REJECTED: 'rejected';
  EXPIRED: 'expired';
  CANCELLED: 'cancelled';
}

export interface QuoteItem {
  id: string;
  quote: string;
  designation: string;
  description?: string;
  quantity: number;
  unit: string;
  unit_price: number;
  discount: number;
  vat_rate: string;
  vat_rate_display: string;
  total_ht: number;
  total_ttc: number;
  position: number;
  type: 'product' | 'service' | 'work' | 'chapter' | 'section' | 'discount'; // ‚úÖ Types Django unifi√©s
  parent?: string;
  reference?: string;
  margin?: number;
  work_id?: string;
}

// Types pour l'√©diteur avanc√© - ALIGN√âS AVEC LE BACKEND DJANGO
export interface EditorQuoteItem {
  id?: string;
  designation: string;
  description?: string;
  quantity: number;
  unit: string;
  unitPrice: number;
  discount: number;                    // ‚úÖ CORRIG√â : discount (pas discountPercentage)
  vat_rate: string;                    // ‚úÖ CORRIG√â : vat_rate string (pas tvaRate)
  type: 'product' | 'service' | 'work' | 'chapter' | 'section' | 'discount'; // ‚úÖ Types Django exactes
  reference?: string;
  position?: number;
  parent?: string;
  totalHt?: number;
  totalTtc?: number;
  margin?: number;
  work_id?: string;
}

export interface BulkQuoteData {
  quote: {
    tier: string;                    // ‚úÖ OBLIGATOIRE - ForeignKey vers Tiers
    validity_period?: number;        // ‚úÖ Dur√©e de validit√© en jours
    notes?: string;                  // ‚úÖ Notes du devis
    conditions?: string;             // ‚úÖ Conditions g√©n√©rales (maps to terms_and_conditions)
    opportunity?: string;            // ‚úÖ ID de l'opportunit√© associ√©e
    // Champs auto-g√©n√©r√©s par Django (√† ne pas envoyer)
    // client_name, client_address, issue_date, expiry_date, number, status
  };
  items: EditorQuoteItem[];
}

export interface BatchOperation {
  type: 'create' | 'update' | 'delete';
  item_id?: string;
  data?: Partial<EditorQuoteItem>;
}

export interface Quote {
  id: string;
  number: string;
  status: string;
  status_display: string;
  tier: string;
  client_name: string;
  client_type: string;
  client_address: string;
  issue_date: string;
  expiry_date: string;
  issue_date_formatted: string;
  expiry_date_formatted: string;
  validity_period: number;
  notes?: string;
  conditions?: string;
  opportunity?: string;
  total_ht: number;
  total_tva: number;
  total_ttc: number;
  items_count: number;
  created_at: string;
  updated_at: string;
  created_by?: string;
  updated_by?: string;
}

export interface QuoteDetail extends Quote {
  tier_details: any;
  items: QuoteItem[];
  items_stats: {
    total_items: number;
    chapters: number;
    sections: number;
    products: number;
    services: number;
    works: number;
    discounts: number;
  };
  vat_breakdown: Array<{
    rate: number;
    base_ht: number;
    vat_amount: number;
  }>;
  opportunity_details?: {
    id: string;
    name: string;
    stage: string;
    stage_display: string;
    probability: number;
    amount: number;
  };
}

export interface QuoteStats {
  total: number;
  draft: number;
  sent: number;
  accepted: number;
  rejected: number;
  expired: number;
  cancelled: number;
  total_amount: number;
  acceptance_rate: number;
}

export interface QuoteFilters {
  status?: string;
  client_id?: string;
  status_list?: string;
  date_from?: string;
  date_to?: string;
  min_amount?: number;
  max_amount?: number;
  search?: string;
  ordering?: string;
  // üöÄ NOUVEAUX: Param√®tres de pagination
  page?: number;
  page_size?: number;
}

// üìä Types pour la pagination (similaires aux tiers)
export interface QuotesPaginationInfo {
  count: number;
  num_pages: number;
  current_page: number;
  page_size: number;
  has_next: boolean;
  has_previous: boolean;
  next_page: number | null;
  previous_page: number | null;
}

export interface QuotesPaginatedResponse {
  results: Quote[];
  pagination: QuotesPaginationInfo;
}

export interface CreateQuoteData {
  tier: string;
  validity_period?: number;
  notes?: string;
  conditions?: string;
  opportunity?: string;
}

export interface CreateQuoteItemData {
  quote: string;
  designation: string;
  description?: string;
  quantity: number;
  unit: string;
  unit_price: number;
  discount?: number;
  vat_rate: string;
  type: 'product' | 'service' | 'work' | 'chapter' | 'section' | 'discount'; // ‚úÖ Types Django unifi√©s
  parent?: string;
  reference?: string;
  margin?: number;
  work_id?: string;
  position?: number;  // ‚úÖ AJOUT√â pour √©liminer l'erreur
}

// API Devis
export const quotesApi = {
  // ==================== DEVIS ====================
  
  // üìä R√©cup√©rer les statistiques globales des devis - OPTIMIS√â
  getStats: async (search?: string): Promise<QuoteStats> => {
    try {
      console.log("üìä API: R√©cup√©ration des statistiques globales des devis");
      
      const params = new URLSearchParams();
      if (search && search.trim()) {
        params.append('search', search.trim());
      }
      
      const response = await apiClient.get(`/quotes/stats/?${params.toString()}`);
      console.log("üìä Stats devis re√ßues:", response.data);
      return response.data;
    } catch (error) {
      console.error("üö® Erreur lors du chargement des stats devis:", error);
      // Retourner des stats vides en cas d'erreur
      return {
        total: 0,
        draft: 0,
        sent: 0,
        accepted: 0,
        rejected: 0,
        expired: 0,
        cancelled: 0,
        total_amount: 0,
        acceptance_rate: 0
      };
    }
  },

  // üöÄ R√©cup√©rer les devis AVEC PAGINATION OPTIMIS√âE
  getQuotes: async (filters?: QuoteFilters): Promise<QuotesPaginatedResponse> => {
    try {
      console.log("üöÄ API OPTIMIS√âE: R√©cup√©ration pagin√©e des devis", filters);
      
      const params = new URLSearchParams();
      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            params.append(key, value.toString());
          }
        });
      }
      
      const response = await apiClient.get(`/quotes/?${params.toString()}`);
      console.log("üìä R√©ponse API pagin√©e devis:", response.data);
      
      // V√©rifier si la r√©ponse est pagin√©e ou directe (r√©trocompatibilit√©)
      const isPaginated = response.data.pagination && response.data.results;
      
      if (isPaginated) {
        // üéØ NOUVELLE STRUCTURE PAGIN√âE
        console.log("‚úÖ Structure pagin√©e d√©tect√©e");
        return {
          results: response.data.results,
          pagination: response.data.pagination
        };
      } else {
        // üîÑ ANCIENNE STRUCTURE (fallback) - √† supprimer apr√®s migration
        console.warn("‚ö†Ô∏è Ancienne structure d√©tect√©e - utilisant le fallback");
        const quotesData = Array.isArray(response.data) ? response.data : 
                          response.data.results ? response.data.results : [];
        
        return {
          results: quotesData,
          pagination: {
            count: quotesData.length,
            num_pages: 1,
            current_page: 1,
            page_size: quotesData.length,
            has_next: false,
            has_previous: false,
            next_page: null,
            previous_page: null
          }
        };
      }
    } catch (error) {
      console.error("üö® Erreur lors du chargement des devis:", error);
      throw error;
    }
  },

  // M√âTHODE LEGACY - garde pour compatibilit√© temporaire
  getQuotesLegacy: async (filters?: QuoteFilters): Promise<Quote[]> => {
    try {
      const response = await quotesApi.getQuotes(filters);
      return response.results;
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des devis (legacy):', error);
      throw error;
    }
  },

  // R√©cup√©rer un devis par ID avec tous les d√©tails
  getQuote: async (id: string): Promise<QuoteDetail> => {
    try {
      const response = await apiClient.get(`/quotes/${id}/`);
      return response.data;
    } catch (error) {
      console.error(`Erreur lors du chargement du devis ${id}:`, error);
      throw error;
    }
  },

  // Cr√©er un nouveau devis
  createQuote: async (quoteData: CreateQuoteData): Promise<Quote> => {
    try {
      const response = await apiClient.post('/quotes/', quoteData);
      return response.data;
    } catch (error) {
      console.error("Erreur lors de la cr√©ation du devis:", error);
      throw error;
    }
  },

  // Mettre √† jour un devis
  updateQuote: async (id: string, quoteData: Partial<CreateQuoteData>): Promise<Quote> => {
    try {
      const response = await apiClient.patch(`/quotes/${id}/`, quoteData);
      return response.data;
    } catch (error) {
      console.error(`Erreur lors de la mise √† jour du devis ${id}:`, error);
      throw error;
    }
  },

  // Supprimer un devis
  deleteQuote: async (id: string): Promise<void> => {
    try {
      await apiClient.delete(`/quotes/${id}/`);
    } catch (error) {
      console.error(`Erreur lors de la suppression du devis ${id}:`, error);
      throw error;
    }
  },

  // ==================== NOUVEAUX ENDPOINTS BULK ====================

  // Cr√©ation compl√®te d'un devis avec tous ses √©l√©ments en une seule transaction
  bulkCreateQuote: async (quoteData: BulkQuoteData): Promise<QuoteDetail> => {
    try {
      console.log("üöÄ === API BULK CREATE - D√âBUT ===");
      console.log("üöÄ URL:", '/quotes/bulk_create/');
      console.log("üöÄ Method:", 'POST');
      console.log("üöÄ Payload complet:", JSON.stringify(quoteData, null, 2));
      console.log("üöÄ Headers:", {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token') || 'NO_TOKEN'}`
      });
      console.log("üöÄ === ENVOI REQU√äTE ===");
      
      const response = await apiClient.post('/quotes/bulk_create/', quoteData);
      
      console.log("‚úÖ === R√âPONSE BULK CREATE ===");
      console.log("‚úÖ Status:", response.status);
      console.log("‚úÖ Status Text:", response.statusText);
      console.log("‚úÖ Headers r√©ponse:", response.headers);
      console.log("‚úÖ Donn√©es r√©ponse:", JSON.stringify(response.data, null, 2));
      console.log("‚úÖ === FIN R√âPONSE ===");
      
      return response.data.quote;
    } catch (error: any) {
      console.error("üö® === ERREUR BULK CREATE ===");
      console.error("üö® Error object:", error);
      console.error("üö® Request URL:", error.config?.url);
      console.error("üö® Request method:", error.config?.method);
      console.error("üö® Request data:", error.config?.data);
      console.error("üö® Response status:", error.response?.status);
      console.error("üö® Response statusText:", error.response?.statusText);
      console.error("üö® Response headers:", error.response?.headers);
      console.error("üö® Response data:", JSON.stringify(error.response?.data, null, 2));
      console.error("üö® Network error?:", !error.response);
      console.error("üö® === FIN ERREUR BULK CREATE ===");
      throw error;
    }
  },

  // Mise √† jour compl√®te d'un devis avec tous ses √©l√©ments en une seule transaction
  bulkUpdateQuote: async (id: string, quoteData: BulkQuoteData): Promise<QuoteDetail> => {
    try {
      console.log("üìù === API BULK UPDATE - D√âBUT ===");
      console.log("üìù URL:", `/quotes/${id}/bulk_update/`);
      console.log("üìù Method:", 'PUT');
      console.log("üìù ID devis:", id);
      console.log("üìù Payload complet:", JSON.stringify(quoteData, null, 2));
      console.log("üìù Headers:", {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token') || 'NO_TOKEN'}`
      });
      console.log("üìù === ENVOI REQU√äTE ===");
      
      const response = await apiClient.put(`/quotes/${id}/bulk_update/`, quoteData);
      
      console.log("‚úÖ === R√âPONSE BULK UPDATE ===");
      console.log("‚úÖ Status:", response.status);
      console.log("‚úÖ Status Text:", response.statusText);
      console.log("‚úÖ Headers r√©ponse:", response.headers);
      console.log("‚úÖ Donn√©es r√©ponse:", JSON.stringify(response.data, null, 2));
      console.log("‚úÖ === FIN R√âPONSE ===");
      
      return response.data.quote;
    } catch (error: any) {
      console.error("üö® === ERREUR BULK UPDATE ===");
      console.error("üö® Error object:", error);
      console.error("üö® Request URL:", error.config?.url);
      console.error("üö® Request method:", error.config?.method);
      console.error("üö® Request data:", error.config?.data);
      console.error("üö® Response status:", error.response?.status);
      console.error("üö® Response statusText:", error.response?.statusText);
      console.error("üö® Response headers:", error.response?.headers);
      console.error("üö® Response data:", JSON.stringify(error.response?.data, null, 2));
      console.error("üö® Network error?:", !error.response);
      console.error("üö® === FIN ERREUR BULK UPDATE ===");
      throw error;
    }
  },

  // ==================== ACTIONS SUR LES DEVIS ====================

  // Marquer un devis comme envoy√©
  markAsSent: async (id: string, note?: string): Promise<Quote> => {
    try {
      const response = await apiClient.post(`/quotes/${id}/mark_as_sent/`, { note });
      return response.data.quote;
    } catch (error) {
      console.error(`Erreur lors de l'envoi du devis ${id}:`, error);
      throw error;
    }
  },

  // Marquer un devis comme accept√©
  markAsAccepted: async (id: string, note?: string): Promise<Quote> => {
    try {
      const response = await apiClient.post(`/quotes/${id}/mark_as_accepted/`, { note });
      return response.data.quote;
    } catch (error) {
      console.error(`Erreur lors de l'acceptation du devis ${id}:`, error);
      throw error;
    }
  },

  // Marquer un devis comme refus√©
  markAsRejected: async (id: string, note?: string): Promise<Quote> => {
    try {
      const response = await apiClient.post(`/quotes/${id}/mark_as_rejected/`, { note });
      return response.data.quote;
    } catch (error) {
      console.error(`Erreur lors du refus du devis ${id}:`, error);
      throw error;
    }
  },

  // Marquer un devis comme annul√©
  markAsCancelled: async (id: string, note?: string): Promise<Quote> => {
    try {
      const response = await apiClient.post(`/quotes/${id}/mark_as_cancelled/`, { note });
      return response.data.quote;
    } catch (error) {
      console.error(`Erreur lors de l'annulation du devis ${id}:`, error);
      throw error;
    }
  },

  // Dupliquer un devis
  duplicateQuote: async (id: string, options?: {
    copy_items?: boolean;
    new_number?: string;
  }): Promise<QuoteDetail> => {
    try {
      const response = await apiClient.post(`/quotes/${id}/duplicate/`, options || {});
      return response.data.quote;
    } catch (error) {
      console.error(`Erreur lors de la duplication du devis ${id}:`, error);
      throw error;
    }
  },

  // Exporter un devis
  exportQuote: async (id: string, format: 'pdf' | 'excel' | 'csv' = 'pdf'): Promise<{ 
    download_url: string; 
    filename: string; 
  }> => {
    try {
      const response = await apiClient.post(`/quotes/${id}/export/`, { format });
      return response.data;
    } catch (error) {
      console.error(`Erreur lors de l'export du devis ${id}:`, error);
      throw error;
    }
  },

  // ==================== √âL√âMENTS DE DEVIS ====================

  // R√©cup√©rer tous les √©l√©ments d'un devis
  getQuoteItems: async (quoteId: string): Promise<QuoteItem[]> => {
    try {
      const response = await apiClient.get(`/quotes/quote-items/by_quote/?quote_id=${quoteId}`);
      return response.data.items;
    } catch (error) {
      console.error(`Erreur lors du chargement des √©l√©ments du devis ${quoteId}:`, error);
      throw error;
    }
  },

  // R√©cup√©rer un √©l√©ment de devis par ID
  getQuoteItem: async (id: string): Promise<QuoteItem> => {
    try {
      const response = await apiClient.get(`/quotes/quote-items/${id}/`);
      return response.data;
    } catch (error) {
      console.error(`Erreur lors du chargement de l'√©l√©ment ${id}:`, error);
      throw error;
    }
  },

  // Cr√©er un nouvel √©l√©ment de devis
  createQuoteItem: async (itemData: CreateQuoteItemData): Promise<QuoteItem> => {
    try {
      const response = await apiClient.post('/quotes/quote-items/', itemData);
      return response.data;
    } catch (error) {
      console.error("Erreur lors de la cr√©ation de l'√©l√©ment:", error);
      throw error;
    }
  },

  // Mettre √† jour un √©l√©ment de devis
  updateQuoteItem: async (id: string, itemData: Partial<CreateQuoteItemData>): Promise<QuoteItem> => {
    try {
      const response = await apiClient.patch(`/quotes/quote-items/${id}/`, itemData);
      return response.data;
    } catch (error) {
      console.error(`Erreur lors de la mise √† jour de l'√©l√©ment ${id}:`, error);
      throw error;
    }
  },

  // Supprimer un √©l√©ment de devis
  deleteQuoteItem: async (id: string): Promise<void> => {
    try {
      await apiClient.delete(`/quotes/quote-items/${id}/`);
    } catch (error) {
      console.error(`Erreur lors de la suppression de l'√©l√©ment ${id}:`, error);
      throw error;
    }
  },

  // R√©organiser les √©l√©ments d'un devis
  reorderQuoteItems: async (itemsOrder: string[]): Promise<void> => {
    try {
      console.log("API: R√©organisation des √©l√©ments", itemsOrder);
      await apiClient.post('/quotes/quote-items/reorder/', { items_order: itemsOrder });
    } catch (error) {
      console.error("Erreur lors de la r√©organisation des √©l√©ments:", error);
      throw error;
    }
  },

  // ==================== NOUVEAUX ENDPOINTS POUR L'√âDITEUR ====================

  // Op√©rations en lot sur les √©l√©ments
  batchOperations: async (operations: BatchOperation[]): Promise<{
    results: Array<{
      operation: string;
      item_id: string;
      success: boolean;
    }>;
  }> => {
    try {
      console.log("API: Op√©rations en lot sur les √©l√©ments", operations);
      const response = await apiClient.post('/quotes/quote-items/batch_operations/', { operations });
      console.log("R√©ponse op√©rations en lot:", response.data);
      return response.data;
    } catch (error) {
      console.error("Erreur lors des op√©rations en lot:", error);
      throw error;
    }
  },

  // ==================== UTILITAIRES ====================

  // Rechercher des devis
  searchQuotes: async (query: string): Promise<Quote[]> => {
    try {
      const response = await quotesApi.getQuotes({ search: query });
      return response.results;
    } catch (error) {
      console.error("Erreur lors de la recherche de devis:", error);
      throw error;
    }
  },

  // Obtenir les devis d'un client
  getQuotesByClient: async (clientId: string): Promise<Quote[]> => {
    try {
      const response = await quotesApi.getQuotes({ client_id: clientId });
      return response.results;
    } catch (error) {
      console.error(`Erreur lors du chargement des devis du client ${clientId}:`, error);
      throw error;
    }
  },

  // Obtenir les devis par statut
  getQuotesByStatus: async (status: string): Promise<Quote[]> => {
    try {
      const response = await quotesApi.getQuotes({ status });
      return response.results;
    } catch (error) {
      console.error(`Erreur lors du chargement des devis avec le statut ${status}:`, error);
      throw error;
    }
  },

  // ==================== FONCTIONS UTILITAIRES POUR L'√âDITEUR ====================

  // Convertir un QuoteItem backend vers EditorQuoteItem frontend
  backendToEditorItem: (backendItem: QuoteItem): EditorQuoteItem => {
    return {
      id: backendItem.id,
      designation: backendItem.designation,
      description: backendItem.description,
      quantity: backendItem.quantity,
      unit: backendItem.unit,
      unitPrice: backendItem.unit_price,
      discount: backendItem.discount,
      vat_rate: backendItem.vat_rate,
      type: backendItem.type,
      reference: backendItem.reference,
      position: backendItem.position,
      parent: backendItem.parent,
      totalHt: backendItem.total_ht,
      totalTtc: backendItem.total_ttc,
      margin: backendItem.margin,
      work_id: backendItem.work_id,
    };
  },

  // Convertir un EditorQuoteItem frontend vers le format backend
  editorToBackendItem: (editorItem: EditorQuoteItem): Partial<CreateQuoteItemData> => {
    return {
      designation: editorItem.designation,
      description: editorItem.description,
      quantity: editorItem.quantity,
      unit: editorItem.unit,
      unit_price: editorItem.unitPrice,
      discount: editorItem.discount,
      vat_rate: editorItem.vat_rate,
      type: editorItem.type,
      reference: editorItem.reference,
      position: editorItem.position,
      parent: editorItem.parent,
      margin: editorItem.margin,
      work_id: editorItem.work_id,
    };
  },

  // Calculer le total HT d'un √©l√©ment
  calculateItemTotal: (item: EditorQuoteItem): number => {
    const baseTotal = item.quantity * item.unitPrice;
    const discountAmount = baseTotal * (item.discount / 100);
    return baseTotal - discountAmount;
  },

  // Calculer le total TTC d'un √©l√©ment
  calculateItemTotalTTC: (item: EditorQuoteItem): number => {
    const totalHT = quotesApi.calculateItemTotal(item);
    const tvaRate = parseFloat(item.vat_rate) / 100;
    return totalHT * (1 + tvaRate);
  },

  // Calculer les totaux d'une liste d'√©l√©ments
  calculateTotals: (items: EditorQuoteItem[]): {
    totalHT: number;
    totalTVA: number;
    totalTTC: number;
    vatBreakdown: Array<{ rate: number; base: number; amount: number }>;
  } => {
    let totalHT = 0;
    let totalTVA = 0;
    const vatBreakdown = new Map<number, { base: number; amount: number }>();

    items.forEach(item => {
      const itemTotalHT = quotesApi.calculateItemTotal(item);
      const tvaRate = parseFloat(item.vat_rate);
      const tvaAmount = itemTotalHT * (tvaRate / 100);

      totalHT += itemTotalHT;
      totalTVA += tvaAmount;

      if (vatBreakdown.has(tvaRate)) {
        const existing = vatBreakdown.get(tvaRate)!;
        existing.base += itemTotalHT;
        existing.amount += tvaAmount;
      } else {
        vatBreakdown.set(tvaRate, { base: itemTotalHT, amount: tvaAmount });
      }
    });

    const vatBreakdownArray = Array.from(vatBreakdown.entries()).map(([rate, data]) => ({
      rate,
      base: data.base,
      amount: data.amount,
    }));

    return {
      totalHT: Math.round(totalHT * 100) / 100,
      totalTVA: Math.round(totalTVA * 100) / 100,
      totalTTC: Math.round((totalHT + totalTVA) * 100) / 100,
      vatBreakdown: vatBreakdownArray,
    };
  },
}; 